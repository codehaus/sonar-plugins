<rules>

   <rule key="SYNC_LOOP">
      <name><![CDATA[DEADLOCK - Synchronized method can cause deadlock.]]></name>
      <configKey><![CDATA[SYNC_LOOP]]></configKey>
      <category name="Reliability"/>
      <description>Invocation of synchronized method can cause deadlock. To disable this rule, disable ALL Jlint rules starting with DEADLOCK.</description>
   </rule>


   <rule key="LOOP">
      <name><![CDATA[DEADLOCK - Method invocation forms loop in dependency graph.]]></name>
      <configKey><![CDATA[LOOP]]></configKey>
      <category name="Reliability"/>
      <description>Invocation of method forms the loop in class dependency graph. To disable this rule, disable ALL Jlint rules starting with DEADLOCK. </description>
   </rule>


   <rule key="LOCK">
      <name><![CDATA[DEADLOCK - Possible deadlock condition]]></name>
      <configKey><![CDATA[LOCK]]></configKey>
      <category name="Reliability"/>
      <description>A lock is requested while holding lock, with other thread holding and requesting lock.  To disable this rule, disable ALL Jlint rules starting with DEADLOCK.</description>
   </rule>


   <rule key="WAIT">
      <name><![CDATA[DEADLOCK - Possible deadlock on wait()]]></name>
      <configKey><![CDATA[WAIT]]></configKey>
      <category name="Reliability"/>
      <description>Method wait() can be invoked with monitor of other object locked. To disable this rule, disable ALL Jlint rules starting with DEADLOCK.</description>
   </rule>


   <rule key="LOCKLIST">
      <name><![CDATA[DEADLOCK - Holding lock(s)]]></name>
      <configKey><![CDATA[LOCKLIST]]></configKey>
      <category name="Reliability"/>
      <description>Holding ## lock(s): #Lock-list ... #.  To disable this rule, disable ALL Jlint rules starting with DEADLOCK.</description>
   </rule>


   <rule key="WAIT_PATH">
      <name><![CDATA[DEADLOCK - Call to method  can cause deadlock]]></name>
      <configKey><![CDATA[WAIT_PATH]]></configKey>
      <category name="Reliability"/>
      <description>Call sequence to method can cause deadlock in wait().  To disable this rule, disable ALL Jlint rules starting with DEADLOCK.</description>
   </rule>


   <rule key="NOSYNC">
      <name><![CDATA[RACE_CONDITION - Synchronized method overridden by non-synchronized method]]></name>
      <configKey><![CDATA[NOSYNC]]></configKey>
      <category name="Reliability"/>
      <description>Synchronized method is overridden by non-synchronized method of derived class. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION.</description>
   </rule>


   <rule key="CONCURRENT_CALL">
      <name><![CDATA[RACE_CONDITION - Method should be synchronized.]]></name>
      <configKey><![CDATA[CONCURRENT_CALL]]></configKey>
      <category name="Reliability"/>
      <description>Method can be called from different threads and is not synchronized. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION</description>
   </rule>


   <rule key="CONCURRENT_ACCESS">
      <name><![CDATA[RACE_CONDITION - Field should be volatile.]]></name>
      <configKey><![CDATA[CONCURRENT_ACCESS]]></configKey>
      <category name="Reliability"/>
      <description>Field 'X' of class 'Y' can be accessed from different threads and is not volatile. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION</description>
   </rule>


   <rule key="RUN_NOSYNC">
      <name><![CDATA[RACE_CONDITION - Runnable Method should be synchronized.]]></name>
      <configKey><![CDATA[RUN_NOSYNC]]></configKey>
      <category name="Reliability"/>
      <description>Method X implementing 'Runnable' interface is not synchronized. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION</description>
   </rule>


   <rule key="LOCK_ASSIGN">
      <name><![CDATA[RACE_CONDITION - Invalid change of lock]]></name>
      <configKey><![CDATA[LOCK_ASSIGN]]></configKey>
      <category name="Reliability"/>
      <description>Value of lock xx is changed outside synchronization or constructor. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION</description>
   </rule>


   <rule key="LOCK_ASSIGN2">
      <name><![CDATA[RACE_CONDITION - Invalid change of lock (potential ownership)]]></name>
      <configKey><![CDATA[LOCK_ASSIGN2]]></configKey>
      <category name="Reliability"/>
      <description>Value of lock xx is changed while (potentially) owning it. To disable this rule, disable ALL Jlint rules starting with RACE_CONDITION</description>
   </rule>


   <rule key="WAIT_NOSYNC">
      <name><![CDATA[WAIT_NOSYNC - Method called without synchronization]]></name>
      <configKey><![CDATA[WAIT_NOSYNC]]></configKey>
      <category name="Reliability"/>
      <description>Method 'X' is called without synchronizing on 'Y'</description>
   </rule>


   <rule key="NOT_OVERRIDDEN">
      <name><![CDATA[NOT_OVERRIDDEN - Method with same name not overridden in derived class]]></name>
      <configKey><![CDATA[NOT_OVERRIDDEN]]></configKey>
      <category name="Reliability"/>
      <description>Method X is not overridden by method with the same name of derived class 'Y'. To disable this rule, disable ALL Jlint rules starting with NOT_OVERRIDDEN.</description>
   </rule>


   <rule key="EQUALS_NOT_OVERRIDDEN">
      <name><![CDATA[NOT_OVERRIDDEN - hashCode() was overridden but not equals()]]></name>
      <configKey><![CDATA[EQUALS_NOT_OVERRIDDEN]]></configKey>
      <category name="Reliability"/>
      <description>HashCode() was overridden but not equals(). To disable this rule, disable ALL Jlint rules starting with NOT_OVERRIDDEN.</description>
   </rule>


   <rule key="HASHCODE_NOT_OVERRIDDEN">
      <name><![CDATA[NOT_OVERRIDDEN - equals() was overridden but not hashCode()]]></name>
      <configKey><![CDATA[HASHCODE_NOT_OVERRIDDEN]]></configKey>
      <category name="Reliability"/>
      <description>equals() was overridden but not hashCode(). To disable this rule, disable ALL Jlint rules starting with NOT_OVERRIDDEN.</description>
   </rule>


   <rule key="FIELD_REDEFINED">
      <name><![CDATA[FIELD_REDEFINED - Component  in class  shadows one in base class]]></name>
      <configKey><![CDATA[FIELD_REDEFINED]]></configKey>
      <category name="Reliability"/>
      <description>Component 'X' in class 'Y' shadows one in base class 'Z'</description>
   </rule>


   <rule key="SHADOW_LOCAL">
      <name><![CDATA[SHADOW_LOCAL - Local variable  shadows component of class]]></name>
      <configKey><![CDATA[SHADOW_LOCAL]]></configKey>
      <category name="Reliability"/>
      <description>Local variable '%2u' shadows component of class '%3c'</description>
   </rule>


   <rule key="SUPER_FINALIZE">
      <name><![CDATA[SUPER_FINALIZE - Method finalize() doesn't call super.finalize()]]></name>
      <configKey><![CDATA[SUPER_FINALIZE]]></configKey>
      <category name="Reliability"/>
      <description>Method finalize() doesn't call super.finalize()</description>
   </rule>


   <rule key="NULL_PARAM">
      <name><![CDATA[NULL_REFERENCE - Method can be invoked with NULL]]></name>
      <configKey><![CDATA[NULL_PARAM]]></configKey>
      <category name="Reliability"/>
      <description>Method X can be invoked with NULL as Y parameter and this parameter is used without check for NULL. To disable this rule, disable ALL Jlint rules starting with NULL_REFERENCE.</description>
   </rule>


   <rule key="NULL_VAR">
      <name><![CDATA[NULL_REFERENCE - Value of referenced variable may be NULL]]></name>
      <configKey><![CDATA[NULL_VAR]]></configKey>
      <category name="Reliability"/>
      <description>Value of referenced variable 'V' may be NULL. To disable this rule, disable ALL Jlint rules starting with NULL_REFERENCE.</description>
   </rule>


   <rule key="NULL_PTR">
      <name><![CDATA[NULL_REFERENCE - NULL reference can be used]]></name>
      <configKey><![CDATA[NULL_PTR]]></configKey>
      <category name="Reliability"/>
      <description>NULL reference can be used. To disable this rule, disable ALL Jlint rules starting with NULL_REFERENCE.</description>
   </rule>


   <rule key="ZERO_OPERAND">
      <name><![CDATA[ZERO_OPERAND - Zero operand for operation]]></name>
      <configKey><![CDATA[ZERO_OPERAND]]></configKey>
      <category name="Reliability"/>
      <description>Zero operand for X operation</description>
   </rule>


   <rule key="ZERO_RESULT">
      <name><![CDATA[ZERO_RESULT - Result of operation is always 0]]></name>
      <configKey><![CDATA[ZERO_RESULT]]></configKey>
      <category name="Reliability"/>
      <description>Result of operation X is always 0</description>
   </rule>


   <rule key="SHIFT_COUNT">
      <name><![CDATA[DOMAIN - Shift with count]]></name>
      <configKey><![CDATA[SHIFT_COUNT]]></configKey>
      <category name="Reliability"/>
      <description>Shift X with count Y than Z. To disable this rule, disable ALL Jlint rules starting with DOMAIN.</description>
   </rule>


   <rule key="SHIFT_RANGE">
      <name><![CDATA[DOMAIN - Shift count range is out of domain]]></name>
      <configKey><![CDATA[SHIFT_RANGE]]></configKey>
      <category name="Reliability"/>
      <description>Shift X count range [Y,Z] is out of domain. To disable this rule, disable ALL Jlint rules starting with DOMAIN</description>
   </rule>


   <rule key="CONVERSION">
      <name><![CDATA[DOMAIN - Expression value has no intersection with type domain.]]></name>
      <configKey><![CDATA[CONVERSION]]></configKey>
      <category name="Reliability"/>
      <description>Range of expression value has no intersection with X type domain. To disable this rule, disable ALL Jlint rules starting with DOMAIN</description>
   </rule>


   <rule key="TRUNCATION">
      <name><![CDATA[TRUNCATION - Data can be lost as a result of truncation]]></name>
      <configKey><![CDATA[TRUNCATION]]></configKey>
      <category name="Reliability"/>
      <description>Data can be lost as a result of truncation to X</description>
   </rule>


   <rule key="OVERFLOW">
      <name><![CDATA[OVERFLOW - Type cast may not correctly applied]]></name>
      <configKey><![CDATA[OVERFLOW]]></configKey>
      <category name="Reliability"/>
      <description>Maybe type cast is not correctly applied</description>
   </rule>


   <rule key="SAME_RESULT">
      <name><![CDATA[REDUNDANT - Comparison always produces the same result]]></name>
      <configKey><![CDATA[SAME_RESULT]]></configKey>
      <category name="Efficiency"/>
      <description>Comparison always produces the same result. To disable this rule, disable ALL Jlint rules starting with REDUNDANT.</description>
   </rule>


   <rule key="DISJOINT_MASK">
      <name><![CDATA[REDUNDANT - Compared expressions can be equal only when 0]]></name>
      <configKey><![CDATA[DISJOINT_MASK]]></configKey>
      <category name="Reliability"/>
      <description>Compared expressions can be equal only when both of them are 0. To disable this rule, disable ALL Jlint rules starting with REDUNDANT.</description>
   </rule>


   <rule key="NO_EFFECT">
      <name><![CDATA[REDUNDANT - Reminder always equal to the first operand]]></name>
      <configKey><![CDATA[NO_EFFECT]]></configKey>
      <category name="Efficiency"/>
      <description>Reminder always equal to the first operand. To disable this rule, disable ALL Jlint rules starting with REDUNDANT.</description>
   </rule>


   <rule key="SHORT_CHAR_CMP">
      <name><![CDATA[SHORT_CHAR_CMP - Comparison of short with char]]></name>
      <configKey><![CDATA[SHORT_CHAR_CMP]]></configKey>
      <category name="Reliability"/>
      <description>Comparison of short with char</description>
   </rule>


   <rule key="STRING_CMP">
      <name><![CDATA[STRING_CMP - Compare strings as object references]]></name>
      <configKey><![CDATA[STRING_CMP]]></configKey>
      <category name="Efficiency"/>
      <description>Compare strings as object references</description>
   </rule>


   <rule key="WEAK_CMP">
      <name><![CDATA[WEAK_CMP - Replace inequality comparison with equality]]></name>
      <configKey><![CDATA[WEAK_CMP]]></configKey>
      <category name="Maintainability"/>
      <description>Inequality comparison can be replaced with equality comparison</description>
   </rule>


   <rule key="INCOMP_CASE">
      <name><![CDATA[INCOMP_CASE - Switch case constant can't be produced by switch expression]]></name>
      <configKey><![CDATA[INCOMP_CASE]]></configKey>
      <category name="Reliability"/>
      <description>Switch case constant X can't be produced by switch expression</description>
   </rule>


   <rule key="NEG_LEN">
      <name><![CDATA[BOUNDS - Array length is less than zero]]></name>
      <configKey><![CDATA[NEG_LEN]]></configKey>
      <category name="Reliability"/>
      <description>Array length [X,Y] is less than zero. To disable this rule, disable ALL Jlint rules starting with BOUNDS.</description>
   </rule>


   <rule key="MAYBE_NEG_LEN">
      <name><![CDATA[BOUNDS - Array length  may be less than zero]]></name>
      <configKey><![CDATA[MAYBE_NEG_LEN]]></configKey>
      <category name="Reliability"/>
      <description>Array length [X,Y] may be less than zero. To disable this rule, disable ALL Jlint rules starting with BOUNDS.</description>
   </rule>


   <rule key="BAD_INDEX">
      <name><![CDATA[BOUNDS - Index is out of array bounds]]></name>
      <configKey><![CDATA[BAD_INDEX]]></configKey>
      <category name="Reliability"/>
      <description>Index [X,Y] is out of array bounds. To disable this rule, disable ALL Jlint rules starting with BOUNDS.</description>
   </rule>


   <rule key="MAYBE_BAD_INDEX">
      <name><![CDATA[BOUNDS - Index may be out of array bounds]]></name>
      <configKey><![CDATA[MAYBE_BAD_INDEX]]></configKey>
      <category name="Reliability"/>
      <description>Index [X,Y] may be out of array bounds. To disable this rule, disable ALL Jlint rules starting with BOUNDS.</description>
   </rule>

</rules>
