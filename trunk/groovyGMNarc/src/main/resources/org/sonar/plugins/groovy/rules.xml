<rules>

<!-- Basic Rules -->
   <rule key="BooleanInstantiation">
      <name><![CDATA[Boolean Instantiation]]></name>
      <configKey><![CDATA[BooleanInstantiation]]></configKey>
      <category name="Reliability"/>
      <description>Use <em>Boolean.valueOf()</em> for variable values or <em>Boolean.TRUE</em> and <em>Boolean.FALSE</em> for constant values instead of calling the <em>Boolean()</em> constructor directly or calling <em>Boolean.valueOf(true)</em> or <em>Boolean.valueOf(false)</em></description>
   </rule>

   <rule key="EmptyCatchBlock">
      <name><![CDATA[Empty Catch Block]]></name>
      <configKey><![CDATA[EmptyCatchBlock]]></configKey>
      <category name="Reliability"/>
      <description>In most cases, exceptions should not be caught and ignored (swallowed).</description>
   </rule>


   <rule key="EmptyElseBlock">
      <name><![CDATA[Empty Else Block]]></name>
      <configKey><![CDATA[EmptyElseBlock]]></configKey>
      <category name="Reliability"/>
      <description>Empty <em>else</em> blocks are confusing and serve no purpose.</description>
   </rule>

    <rule key="EmptyForStatement">
       <name><![CDATA[Empty For Statement]]></name>
       <configKey><![CDATA[EmptyForStatement]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>for</em> statements are confusing and serve no purpose.</description>
    </rule>

   <rule key="EmptyFinallyBlock">
       <name><![CDATA[Empty Finally Block]]></name>
       <configKey><![CDATA[EmptyFinallyBlock]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>finally</em> blocks are confusing and serve no purpose.</description>
    </rule>


   <rule key="EmptyIfStatement">
       <name><![CDATA[Empty If Statement]]></name>
       <configKey><![CDATA[EmptyIfStatement]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>if</em> statements are confusing and serve no purpose.</description>
    </rule>

    <rule key="EmptySwitchStatement">
       <name><![CDATA[Empty Switch Statement]]></name>
       <configKey><![CDATA[EmptySwitchStatement]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>switch</em> statements are confusing and serve no purpose.</description>
    </rule>

    <rule key="EmptySynchronizedStatement">
       <name><![CDATA[Empty Synchronized Statement]]></name>
       <configKey><![CDATA[EmptySynchronizedStatement]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>Synchronize</em> statements are confusing and serve no purpose.</description>
    </rule>

    <rule key="EmptyTryBlock">
       <name><![CDATA[Empty Try Block]]></name>
       <configKey><![CDATA[EmptyTryBlock]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>try</em> blocks are confusing and serve no purpose.</description>
    </rule>

    <rule key="EmptyWhileStatement">
       <name><![CDATA[Empty While Statement]]></name>
       <configKey><![CDATA[EmptyWhileStatement]]></configKey>
       <category name="Reliability"/>
       <description>Empty <em>while</em> statements are confusing and serve no purpose.</description>
    </rule>

    <rule key="EqualsAndHashCode">
       <name><![CDATA[Equals and Hash Code]]></name>
       <configKey><![CDATA[EqualsAndHashCode]]></configKey>
       <category name="Reliability"/>
       <description>If either the <em>boolean equals(Object)</em> or the <em>int hashCode()</em> methods are overridden within a class, then both must be overridden..</description>
    </rule>

      <rule key="ReturnFromFinallyBlock">
       <name><![CDATA[Return from Finally Block]]></name>
       <configKey><![CDATA[ReturnFromFinallyBlock]]></configKey>
       <category name="Reliability"/>
       <description>Returning from a <em>finally</em> block is confusing and can hide the original exception.</description>
    </rule>

      <rule key="StringInstantiation">
       <name><![CDATA[String Instantiation]]></name>
       <configKey><![CDATA[StringInstantiation]]></configKey>
       <category name="Reliability"/>
       <description>Use a String literal (e.g., "...") instead of calling the corresponding String constructor (new String("..")) directly.</description>
    </rule>

    <rule key="ThrowExceptionFromFinallyBlock">
       <name><![CDATA[Throw Exception From Finally Block]]></name>
       <configKey><![CDATA[ThrowExceptionFromFinallyBlock]]></configKey>
       <category name="Reliability"/>
       <description>Throwing an exception from a <em>finally</em> block is confusing and can hide the original exception..</description>
    </rule>

<!-- Grails Rules -->
    <rule key="GrailsPublicControllerMethod">
       <name><![CDATA[Grails Public Controller Method]]></name>
       <configKey><![CDATA[GrailsPublicControllerMethod]]></configKey>
       <category name="Usability"/>
       <description>Grails controller actions and interceptors are defined as properties on the controller class. Public methods on a controller class are unnecessary. They break encapsulation and can be confusing.</description>
    </rule>

    <rule key="GrailsServletContextReference">
       <name><![CDATA[Grails Servlet Context Reference]]></name>
       <configKey><![CDATA[GrailsServletContextReference]]></configKey>
       <category name="Usability"/>
       <description>Referencing the servletContext may inhibit scalability and/or performance and should be carefully considered.</description>
    </rule>

     <rule key="GrailsSessionReference">
       <name><![CDATA[Grails Session Reference]]></name>
       <configKey><![CDATA[GrailsSessionReference]]></configKey>
       <category name="Usability"/>
       <description>Referencing the session may inhibit scalability and/or performance and should be carefully considered.</description>
    </rule>

     <rule key="GrailsStatelessService">
       <name><![CDATA[Grails Stateless Service]]></name>
       <configKey><![CDATA[GrailsStatelessService]]></configKey>
       <category name="Usability"/>
       <description>Grails service classes are singletons by default, and so they should be reentrant. In most cases, this implies (or at least encourages) that they should be stateless.</description>
    </rule>

<!-- Unused Rules -->
     <rule key="UnusedImport">
       <name><![CDATA[Unused Import]]></name>
       <configKey><![CDATA[UnusedImport]]></configKey>
       <category name="Efficiency"/>
       <description>Imported class is never used</description>
    </rule>

    <rule key="UnusedPrivateField">
       <name><![CDATA[Unused Private Field]]></name>
       <configKey><![CDATA[UnusedPrivateField]]></configKey>
       <category name="Efficiency"/>
       <description>Private field never referenced</description>
    </rule>

    <rule key="UnusedPrivateMethod">
       <name><![CDATA[Unused Private Method]]></name>
       <configKey><![CDATA[UnusedPrivateMethod]]></configKey>
       <category name="Efficiency"/>
       <description>Private Method declared but never used</description>
    </rule>

    <rule key="UnusedVariable">
       <name><![CDATA[Unused Variable]]></name>
       <configKey><![CDATA[UnusedVariable]]></configKey>
       <category name="Efficiency"/>
       <description>Variable declared but never referenced</description>
    </rule>


<!-- Naming Rules -->
    <rule key="AbstractClassName">
       <name><![CDATA[Abstract Class Name]]></name>
       <configKey><![CDATA[AbstractClassName]]></configKey>
       <category name="Maintainability"/>
       <description>Abstract Class declared using unwanted characters</description>
    </rule>

    <rule key="ClassName">
       <name><![CDATA[Class Name]]></name>
       <configKey><![CDATA[ClassName]]></configKey>
       <category name="Maintainability"/>
       <description>Class declared using unwanted characters</description>
    </rule>

    <rule key="FieldName">
       <name><![CDATA[Field Name]]></name>
       <configKey><![CDATA[FieldName]]></configKey>
       <category name="Maintainability"/>
       <description>Field Name declared using unwanted characters </description>
    </rule>

    <rule key="InterfaceName">
       <name><![CDATA[Interface Name]]></name>
       <configKey><![CDATA[InterfaceName]]></configKey>
       <category name="Maintainability"/>
       <description>Interface name does not conform to locally defined standards. Consult your administrator for more information.</description>
    </rule>

    <rule key="MethodName">
       <name><![CDATA[Method Name]]></name>
       <configKey><![CDATA[MethodName]]></configKey>
       <category name="Maintainability"/>
       <description>Method name does not conform to locally defined standards(possibly starts with upper case?). Consult your administrator for more information.</description>
    </rule>

    <rule key="PackageName">
       <name><![CDATA[Package Name]]></name>
       <configKey><![CDATA[PackageName]]></configKey>
       <category name="Maintainability"/>
       <description>Package name does not conform to locally defined standards(possibly contains uppercase or numbers?). Consult your administrator for more information.</description>
    </rule>

    <rule key="ParameterName">
       <name><![CDATA[Parameter Name]]></name>
       <configKey><![CDATA[ParameterName]]></configKey>
       <category name="Maintainability"/>
       <description>Parameter name does not conform to locally defined standards(possibly starts with uppercase?). Consult your administrator for more information.</description>
    </rule>


    <rule key="PropertyName">
       <name><![CDATA[Property Name]]></name>
       <configKey><![CDATA[PropertyName]]></configKey>
       <category name="Maintainability"/>
       <description>Property name does not conform to locally defined standards. Property name should start with a lowercase letter and contain only letters or numbers. If declared <i>final</i> it may contain only uppercase and numbers or uderscores. Consult your administrator for more information.</description>
    </rule>

    <rule key="VariableName">
       <name><![CDATA[Variable Name]]></name>
       <configKey><![CDATA[VariableName]]></configKey>
       <category name="Maintainability"/>
       <description>Variable name does not conform to locally defined standards(possibly starts with uppercase?). Consult your administrator for more information.</description>
    </rule>

<!-- Braces Rules -->
    <rule key="ElseBlockBraces">
        <name><![CDATA[Else Block Braces]]></name>
        <configKey><![CDATA[ElseBlockBraces]]></configKey>
        <category name="Reliability"/>
        <description>Else block should use braces, even for a single statement.</description>
     </rule>

     <rule key="ForStatementBraces">
        <name><![CDATA[For Statement Braces]]></name>
        <configKey><![CDATA[ForStatementBraces]]></configKey>
        <category name="Reliability"/>
        <description>For block should use braces, even for a single statement.</description>
     </rule>

     <rule key="IfStatementBraces">
        <name><![CDATA[If Statement Braces]]></name>
        <configKey><![CDATA[IfStatementBraces]]></configKey>
        <category name="Reliability"/>
        <description>If block should use braces, even for a single statement.</description>
     </rule>

     <rule key="WhileStatementBraces">
        <name><![CDATA[While Statement Braces]]></name>
        <configKey><![CDATA[WhileStatementBraces]]></configKey>
        <category name="Reliability"/>
        <description>While block should use braces, even for a single statement.</description>
     </rule>

<!-- Exception Rules -->
     <rule key="CatchError">
        <name><![CDATA[Catch Error]]></name>
        <configKey><![CDATA[CatchError]]></configKey>
        <category name="Reliability"/>
        <description>In most cases this is much too broad, and is also dangerous because it can catch exceptions such as ThreadDeath  and OutOfMemoryError.</description>
     </rule>

     <rule key="CatchException">
        <name><![CDATA[Catch Exception]]></name>
        <configKey><![CDATA[CatchException]]></configKey>
        <category name="Reliability"/>
        <description>In most cases this is too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.</description>
     </rule>

     <rule key="CatchNullPointerException">
        <name><![CDATA[Catch Null Pointer Exception]]></name>
        <configKey><![CDATA[CatchNullPointerException]]></configKey>
        <category name="Reliability"/>
        <description>Catching NullPointerException  is never appropriate. It should be avoided in the first place with proper null checking, and it can mask underlying errors.</description>
     </rule>

     <rule key="CatchRuntimeException">
        <name><![CDATA[Catch Runtime Exception]]></name>
        <configKey><![CDATA[CatchRuntimeException]]></configKey>
        <category name="Reliability"/>
        <description>In most cases this is too broad or general. It should usually be restricted to framework or infrastructure code, rather than application code.</description>
     </rule>

     <rule key="CatchThrowable">
        <name><![CDATA[Catch Throwable]]></name>
        <configKey><![CDATA[CatchThrowable]]></configKey>
        <category name="Reliability"/>
        <description>In most cases this is much too broad, and is also dangerous because it can catch exceptions such as ThreadDeath  and OutOfMemoryError .</description>
     </rule>

      <rule key="ThrowError">
        <name><![CDATA[Throw Error]]></name>
        <configKey><![CDATA[ThrowError]]></configKey>
        <category name="Reliability"/>
        <description>This is not appropriate within normal application code. Throw an instance of a more specific exception subclass instead.</description>
     </rule>

     <rule key="ThrowException">
        <name><![CDATA[Throw Exception]]></name>
        <configKey><![CDATA[ThrowException]]></configKey>
        <category name="Reliability"/>
        <description>Throw an instance of a more specific exception subclass instead.</description>
     </rule>

     <rule key="ThrowNullPointerException">
        <name><![CDATA[Throw Null Pointer Exception]]></name>
        <configKey><![CDATA[ThrowNullPointerException]]></configKey>
        <category name="Reliability"/>
        <description>Applications should never throw a NullPointerException.</description>
     </rule>

      <rule key="ThrowRuntimeException">
        <name><![CDATA[Throw Runtime Exception]]></name>
        <configKey><![CDATA[ThrowRuntimeException]]></configKey>
        <category name="Reliability"/>
        <description>Throw an instance of a more specific exception subclass instead.</description>
     </rule>

     <rule key="ThrowThrowable">
        <name><![CDATA[Throw Throwable]]></name>
        <configKey><![CDATA[ThrowThrowable]]></configKey>
        <category name="Reliability"/>
        <description>Throw an instance of a more specific exception subclass instead.</description>
     </rule>

<!-- Generic Rules -->

      <rule key="IllegalRegex">
        <name><![CDATA[Illegal Regex]]></name>
        <configKey><![CDATA[IllegalRegex]]></configKey>
        <category name="Maintainability"/>
        <description>Illegal Regex. Expressions like this have been flagged by your local admins and should be avoided.</description>
     </rule>

      <rule key="RequiredRegex">
        <name><![CDATA[Required Regex]]></name>
        <configKey><![CDATA[RequiredRegex]]></configKey>
        <category name="Maintainability"/>
        <description>A Regex as required by the local ruleset is missing.</description>
     </rule>

     <rule key="StatelessClass">
        <name><![CDATA[Stateless Class]]></name>
        <configKey><![CDATA[StatelessClass]]></configKey>
        <category name="Maintainability"/>
        <description>Classes should remain stateless. Check for non-final fields on the class.</description>
     </rule>

<!-- Import Rules -->

      <rule key="DuplicateImport">
        <name><![CDATA[Duplicate Import]]></name>
        <configKey><![CDATA[DuplicateImport]]></configKey>
        <category name="Efficiency"/>
        <description>Import duplicated.</description>
     </rule>

      <rule key="ImportFromSamePackage">
        <name><![CDATA[Import From Same Package]]></name>
        <configKey><![CDATA[ImportFromSamePackage]]></configKey>
        <category name="Efficiency"/>
        <description>Import in same class as the importing class.</description>
     </rule>

     <rule key="UnnecessaryGroovyImport">
        <name><![CDATA[Unnecessary Groovy Import]]></name>
        <configKey><![CDATA[UnnecessaryGroovyImport]]></configKey>
        <category name="Efficiency"/>
        <description>Import is automatically done by Groovy so does not need to be explicitly imported.</description>
     </rule>


<!-- JUnit Rules -->

      <rule key="JUnitAssertAlwaysFails">
        <name><![CDATA[JUnit Assert Always Fails]]></name>
        <configKey><![CDATA[JUnitAssertAlwaysFails]]></configKey>
        <category name="Reliability"/>
        <description>Assertion always fails. Check usage.</description>
     </rule>

      <rule key="JUnitAssertAlwaysSucceeds">
        <name><![CDATA[JUnit Assert Always Succeeds]]></name>
        <configKey><![CDATA[JUnitAssertAlwaysSucceeds]]></configKey>
        <category name="Reliability"/>
        <description>Assertion always succeeds. Check usage.</description>
     </rule>

     <rule key="JUnitPublicNonTestMethod">
        <name><![CDATA[JUnit Public Non Test Method]]></name>
        <configKey><![CDATA[JUnitPublicNonTestMethod]]></configKey>
        <category name="Reliability"/>
        <description>Public, non-test methods on a test class violate conventional usage of test classes, and they typically break encapsulation unnecessarily.</description>
     </rule>

     <rule key="JUnitSetUpCallsSuper">
        <name><![CDATA[JUnit SetUp Calls Super]]></name>
        <configKey><![CDATA[JUnitSetUpCallsSuper]]></configKey>
        <category name="Reliability"/>
        <description>Setup method should include a call to super.setUp().</description>
     </rule>

      <rule key="JUnitTearDownCallsSuper">
        <name><![CDATA[JUnit Tear Down Calls Super]]></name>
        <configKey><![CDATA[JUnitTearDownCallsSuper]]></configKey>
        <category name="Reliability"/>
        <description>Teardown method should include a call to super.tearDown().</description>
     </rule>


<!-- Logging Rules -->

      <rule key="Println">
        <name><![CDATA[Println]]></name>
        <configKey><![CDATA[Println]]></configKey>
        <category name="Usability"/>
        <description>Consider using a standard logging facility instead.</description>
     </rule>

      <rule key="PrintStackTrace">
        <name><![CDATA[Print Stack Trace]]></name>
        <configKey><![CDATA[PrintStackTrace]]></configKey>
        <category name="Usability"/>
        <description>Consider using a standard logging facility instead.</description>
     </rule>

     <rule key="SystemOutPrint">
        <name><![CDATA[System Out Print]]></name>
        <configKey><![CDATA[SystemOutPrint]]></configKey>
        <category name="Usability"/>
        <description>Consider using a standard logging facility instead.</description>
     </rule>


<!-- Size/Complexity Rules -->

      <rule key="ClassSize">
        <name><![CDATA[Class Size]]></name>
        <configKey><![CDATA[ClassSize]]></configKey>
        <category name="Maintainability"/>
        <description>Class size exceeds the maximum number of lines as specified by maxLines property.</description>
     </rule>

      <rule key="MethodSize">
        <name><![CDATA[Method Size]]></name>
        <configKey><![CDATA[MethodSize]]></configKey>
        <category name="Maintainability"/>
        <description>Method size exceeds the maximum number of lines as specified by maxLines property.</description>
     </rule>

     <rule key="NestedBlockDepthRule">
        <name><![CDATA[Nested Block Depth Rule]]></name>
        <configKey><![CDATA[NestedBlockDepthRule]]></configKey>
        <category name="Maintainability"/>
        <description>Nested depth  exceeds the maximum number of lines as specified by maxNestedBlockDepth property.</description>
     </rule>


</rules>