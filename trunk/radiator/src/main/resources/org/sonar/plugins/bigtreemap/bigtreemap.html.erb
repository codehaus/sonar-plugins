<%
# The 1.1.3 jit script need to be modified with the following code
# line 8138 makes tree map anchors work :
# var from = e.target || e.srcElement;
# if (from instanceof HTMLAnchorElement) {
# 	// event originated form an anchor link, returning
# 	return;
# }
#
# line 7606 (replace jit tip css class name on tip elements by sonar tooltip css class name) :
# tip.className = 'tooltip';
%>
<%= javascript_include_tag 'jit-yc' %>
<style type="text/css">
#bigtreemap {
    position: relative;
    height:600px;
}
#bigtreemap div {
    position:absolute;
    overflow:hidden;
    padding-top: 4px;
    padding-left: 4px;
}
#bigtreemap .content {
    background-color:white;
}
#bigtreemap .head {
    color:white;
    background-color:#444;
}
#bigtreemap .head.in-path {
    background-color:#655;
}
#bigtreemap .body {
    background-color:white;
}
#bigtreemap .leaf {
    color:white;
    display:table-cell;
    vertical-align:middle;
}
#bigtreemap .over-leaf {
    border:1px solid #9FD4FF; 
}
#bigtreemap .over-content {
    background-color: #9FD4FF;
}
#bigtreemap .over-head { /* boy i'm funny! */
    background-color:#A4D9FF;
    color:red;
}
</style>
<%= render :partial => '/project/snapshot_title' %>
<form name="tm_controls" style="padding-top:10px; padding-left:6px;">
	<table>
		<tr>
		    <td>
		      <span class="comments">Size:</span>
		      <%= select_tag 'size_metric', options_from_collection_for_select(
		        Sonar::TreemapBuilder.size_metrics, :key, :short_name, Sonar::TreemapBuilder.default_size_metric.key),
		        :id => 'select_size_metric', :class => 'small',:onchange => "load_bigtreemap(current_resource_key);" %>
		    </td>
		    <td>
		      <span class="comments">Color:</span>
		      <%= select_tag 'color_metric', options_from_collection_for_select(
		          Sonar::TreemapBuilder.color_metrics, :key, :short_name, Sonar::TreemapBuilder.default_color_metric.key),
		          :id => 'select_color_metric', :class => 'small', :onchange => "load_bigtreemap(current_resource_key);" %>
		    </td>
		    <td>
		     	<%
		     	layout = params[:layout]
		     	layout = (layout == 'true' || layout.nil? ) ? 'false' : 'true'
		     	alt = (layout == 'true' || layout.nil? ) ? 'Collapse' : 'Expand'
		     	%>
		    	<span style="padding-left:15px"><%= link_to(image_tag('expand_collapse.jpg', :alt => alt), {:layout => layout}) %>
		    </td>
		    <td valign="top">
				<span style="padding-left:15px"><%= image_tag('loading.gif', {:id => "tm_loading"}) %></span>
			</td>
		</tr>
	</table>
</form>
<div id="bigtreemap"></div>

<script language="javascript">

	var treemap = null;
	var all_projects_radiator = <%= @project.nil? ? 'true' : 'false' %>;
	var current_resource_key = null;
	var parent_resource_key = <%= @project.nil? ? 'null' : "'#{@project.key}'" %>;
	var size_metric = null;
	var color_metric = null;
	
	var dimensions = $('content').getDimensions();
	$('bigtreemap').style.width=dimensions.width;
	$('bigtreemap').style.height=dimensions.height;
	
	TM.Squarified.implement({  
	       onLeftClick: function(elem) {
	          load_bigtreemap(elem.parentNode.id);
	       },
	       onRightClick: function() {
			 load = (all_projects_radiator && parent_resource_key == null) || parent_resource_key != null;
			 if (load) {
	         	load_bigtreemap(parent_resource_key);
	         }

	       },
	       leafBox: function(json, coord) {
				var config = this.config;
				var backgroundColor = config.Color.allow && this.setColor(json), 
				offst = config.offset,
				width = coord.width - offst,
				height = coord.height - offst;
				var c = {
				  'top':   (offst / 2)  + "px",
				  'height':height + "px",
				  'width': width + "px",
				  'left': (offst / 2) + "px",
				  'cursor': 'pointer'
				};
				if(backgroundColor) c['background-color'] = backgroundColor;
				return "<div class=\"leaf\" style=\"" + this.toStyle(c) + "\"><a href=\"" + dashboard_url(json.id) + "\">" + json.name + "</a></div>";
            },
            headBox: function(json, coord) {
            	return "<div></div>";
            },
            setColor: function(json) {
              if (json.data.$color == null) {
              	return rgbToHexColor([221, 221, 221]);
              }
              var c = this.config.Color,
			  maxcv = c.maxColorValue,
			  mincv = c.minColorValue,
			  maxv = c.maxValue,
			  minv = c.minValue,
			  diff = maxv - minv,
			  x = (json.data.$color - 0);
			  //linear interpolation    
			  var comp = function(i, x) { 
			    return Math.round((((maxcv[i] - mincv[i]) / diff) * (x - minv) + mincv[i])); 
			  };
			    
			  return rgbToHexColor([ comp(0, x), comp(1, x), comp(2, x) ]);
            }
		});
		
	function dashboard_url(resource_key) {
		return '<%=ApplicationController.root_context-%>/project/index/' + resource_key;
	}
 
	function get_bigtreemap(color_metric_direction) {
	
		return new TM.Squarified({  
		     rootId: 'bigtreemap',  
		     titleHeight: 1,
		     offset: 8,
		     addLeftClickHandler: true,  
		     addRightClickHandler: true,
		     selectPathOnHover: true,  
		               
		     Color: {  
		         allow: true,  
		         minValue: 0,
		         maxValue: 100,
		         maxColorValue: (color_metric_direction == 1 ? [0, 255, 50] : [255, 0, 50]),  
		         minColorValue: (color_metric_direction == 1 ? [255, 0, 50] : [0, 255, 50])  
		     },  
		       
		     //Allow tips  
		     Tips: {  
		       allow: true,  
		       offsetX: 20,  
		       offsetY: 20,  
		       onShow: function(tip, node, isLeaf, domElement) {  
		           tip.innerHTML = "<div class=\"title\">" + node.name + "</div>" +   
		             "<div class=\"content\">" + this.makeHTMLFromData(node.data) + "</div>";   
		       },
		       makeHTMLFromData: function(data){  
		           var html = '<table><tr><td align=left>' + size_metric + '</td><td align=right><b>' + data.size_frmt + 
		           '</b></td></tr><tr><td align=left>' + color_metric + '</td><td align=right><b>' +data.color_frmt + '</b></td></tr></table>';
		           return html;  
		       }
		     },
		   
		     onDestroyElement: function(content, tree, isLeaf, leaf){  
		         if(leaf.clearAttributes) leaf.clearAttributes();  
		     },
		     
		     onLeftClick: function() {  
				alert('onleft');
             }  
	 	}); 
    }
    
    function rgbToHexColor(srcArray, array){
	    var hex = [];
	    for (var i = 0; i < 3; i++){
	        var bit = (srcArray[i] - 0).toString(16);
	        hex.push((bit.length == 1) ? '0' + bit : bit);
	    }
	    return (array) ? hex : '#' + hex.join('');
	};

	function load_bigtreemap(resource_key) {
	    if (treemap != null) {
	    	treemap.empty();
	    	treemap = null;
	    }
	    $('tm_loading').show();
	    
	    url = '<%=ApplicationController.root_context-%>/api/plugins/RubyBigTreemapWebService';
	    if (resource_key != null) {
	    	current_resource_key = resource_key;
	    	url += '?resource=' + resource_key + '&';
	    } else {
	    	url += '?';
	    }
	 
		new Ajax.Request(url + 'size=' + $F('select_size_metric') + '&color=' + $F('select_color_metric') + '&callback=treemapcallback',
		  {
		    method: 'get',
		    requestHeaders: {Accept: 'application/json'},
		    onSuccess: function(transport) {
		      eval(transport.responseText);
		    },
		    onFailure: function(response){ error(response.responseText) }
		  });
	}
	
	function treemapcallback(json) {
		$('tm_loading').hide();
		treemap = get_bigtreemap(json['color_metric_direction']);
		parent_resource_key = json['parent'];
		size_metric = json['size_metric'];
		color_metric = json['color_metric'];
		treemap.loadJSON(json);
	}
	load_bigtreemap(<%= @project.nil? ? 'null' : "'#{@project.key}'" %>);
</script>