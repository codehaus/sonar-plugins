<rules>
	<rule>
		<key>autoVariables</key>
		<priority>MAJOR</priority>
		<name>autoVariables</name>
		<configKey>autoVariables</configKey>
		<category name="Reliability"/>
		<description>Return of the address or invalid deallocation of an auto-variable</description>
	</rule>
	<rule>
		<key>returnLocalVariable</key>
		<priority>MAJOR</priority>
		<name>returnLocalVariable</name>
		<configKey>returnLocalVariable</configKey>
		<category name="Reliability"/>
		<description>Returning pointer to local array variable</description>
	</rule>
	<rule>
		<key>returnReference</key>
		<priority>MAJOR</priority>
		<name>returnReference</name>
		<configKey>returnReference</configKey>
		<category name="Reliability"/>
		<description>Returning reference to auto variable</description>
	</rule>
	<rule>
		<key>returnTempReference</key>
		<priority>MAJOR</priority>
		<name>returnTempReference</name>
		<configKey>returnTempReference</configKey>
		<category name="Reliability"/>
		<description>Returning reference to temporary</description>
	</rule>
	<rule>
		<key>returnAutocstr</key>
		<priority>MAJOR</priority>
		<name>returnAutocstr</name>
		<configKey>returnAutocstr</configKey>
		<category name="Reliability"/>
		<description>Returning pointer to auto variable</description>
	</rule>
	<rule>
		<key>returnTempPointer</key>
		<priority>MAJOR</priority>
		<name>returnTempPointer</name>
		<configKey>returnTempPointer</configKey>
		<category name="Reliability"/>
		<description>Returning pointer to temporary</description>
	</rule>
	<rule>
		<key>memleak</key>
		<priority>MAJOR</priority>
		<name>memleak</name>
		<configKey>memleak</configKey>
		<category name="Reliability"/>
		<description>Memory leak</description>
	</rule>
	<rule>
		<key>memleakOnRealloc</key>
		<priority>MAJOR</priority>
		<name>memleakOnRealloc</name>
		<configKey>memleakOnRealloc</configKey>
		<category name="Reliability"/>
		<description>Common realloc mistake: variable nulled but not freed upon failure</description>
	</rule>
	<rule>
		<key>resourceLeak</key>
		<priority>MAJOR</priority>
		<name>resourceLeak</name>
		<configKey>resourceLeak</configKey>
		<category name="Reliability"/>
		<description>Resource leak</description>
	</rule>
	<rule>
		<key>deallocDealloc</key>
		<priority>MAJOR</priority>
		<name>deallocDealloc</name>
		<configKey>deallocDealloc</configKey>
		<category name="Reliability"/>
		<description>Deallocating a deallocated pointer</description>
	</rule>
	<rule>
		<key>deallocuse</key>
		<priority>MAJOR</priority>
		<name>deallocuse</name>
		<configKey>deallocuse</configKey>
		<category name="Reliability"/>
		<description>Dereferencing variable after it is deallocated / released</description>
	</rule>
	<rule>
		<key>mismatchSize</key>
		<priority>MAJOR</priority>
		<name>mismatchSize</name>
		<configKey>mismatchSize</configKey>
		<category name="Reliability"/>
		<description>The given size is mismatching</description>
	</rule>
	<rule>
		<key>mismatchAllocDealloc</key>
		<priority>MAJOR</priority>
		<name>mismatchAllocDealloc</name>
		<configKey>mismatchAllocDealloc</configKey>
		<category name="Reliability"/>
		<description>Mismatching allocation and deallocation</description>
	</rule>
	<rule>
		<key>debug</key>
		<priority>MINOR</priority>
		<name>debug</name>
		<configKey>debug</configKey>
		<category name="Reliability"/>
		<description>undefine error, the checking continues anyway.</description>
	</rule>
	<rule>
		<key>publicAllocationError</key>
		<priority>MINOR</priority>
		<name>publicAllocationError</name>
		<configKey>publicAllocationError</configKey>
		<category name="Reliability"/>
		<description>Possible leak in public function. The pointer variable is not deallocated before it is allocated.</description>
	</rule>
	<rule>
		<key>leakNoVarFunctionCall</key>
		<priority>MAJOR</priority>
		<name>leakNoVarFunctionCall</name>
		<configKey>leakNoVarFunctionCall</configKey>
		<category name="Reliability"/>
		<description>Allocation not released.</description>
	</rule>
	<rule>
		<key>cppcheckError</key>
		<priority>MAJOR</priority>
		<name>cppcheckError</name>
		<configKey>cppcheckError</configKey>
		<category name="Reliability"/>
		<description>Internal error. Token::Match called with varid 0.</description>
	</rule>
	<rule>
		<key>variableHidingTypedef</key>
		<priority>INFO</priority>
		<name>variableHidingTypedef</name>
		<configKey>variableHidingTypedef</configKey>
		<category name="Reliability"/>
		<description>this hides typedef with same name</description>
	</rule>
	<rule>
		<key>unnecessaryForwardDeclaration</key>
		<priority>INFO</priority>
		<name>unnecessaryForwardDeclaration</name>
		<configKey>unnecessaryForwardDeclaration</configKey>
		<category name="Reliability"/>
		<description>forward declaration unnecessary, already declared</description>
	</rule>
	<rule>
		<key>variableHidingEnum</key>
		<priority>INFO</priority>
		<name>variableHidingEnum</name>
		<configKey>variableHidingEnum</configKey>
		<category name="Reliability"/>
		<description>this hides enumerator with same name</description>
	</rule>
	<rule>
		<key>syntaxError</key>
		<priority>MAJOR</priority>
		<name>syntaxError</name>
		<configKey>syntaxError</configKey>
		<category name="Reliability"/>
		<description>syntax error for : characters that are unhandled, bad source code or bad macro</description>
	</rule>
	<rule>
		<key>cppcheckError</key>
		<priority>MAJOR</priority>
		<name>cppcheckError</name>
		<configKey>cppcheckError</configKey>
		<category name="Reliability"/>
		<description>### Internal error in Cppcheck. Please report it.</description>
	</rule>
	<rule>
		<key>uninitstring</key>
		<priority>MAJOR</priority>
		<name>uninitstring</name>
		<configKey>uninitstring</configKey>
		<category name="Reliability"/>
		<description>Dangerous usage of variable strncpy doesn't always 0-terminate it</description>
	</rule>
	<rule>
		<key>uninitdata</key>
		<priority>MAJOR</priority>
		<name>uninitdata</name>
		<configKey>uninitdata</configKey>
		<category name="Reliability"/>
		<description>Data is allocated but not initialized</description>
	</rule>
	<rule>
		<key>uninitvar</key>
		<priority>MAJOR</priority>
		<name>uninitvar</name>
		<configKey>uninitvar</configKey>
		<category name="Reliability"/>
		<description>Uninitialized variable</description>
	</rule>
	<rule>
		<key>preprocessorErrorDirective</key>
		<priority>MAJOR</priority>
		<name>preprocessorErrorDirective</name>
		<configKey>preprocessorErrorDirective</configKey>
		<category name="Reliability"/>
		<description>preprocessorErrorDirective</description>
	</rule>
	<rule>
		<key>noQuoteCharPair</key>
		<priority>MAJOR</priority>
		<name>noQuoteCharPair</name>
		<configKey>noQuoteCharPair</configKey>
		<category name="Reliability"/>
		<description>No pair for character. Can't process file. File is either invalid or unicode, which is currently not supported.</description>
	</rule>
	<rule>
		<key>missingInclude</key>
		<priority>INFO</priority>
		<name>missingInclude</name>
		<configKey>missingInclude</configKey>
		<category name="Reliability"/>
		<description>Include file: not found.</description>
	</rule>
	<rule>
		<key>nullPointer</key>
		<priority>MAJOR</priority>
		<name>nullPointer</name>
		<configKey>nullPointer</configKey>
		<category name="Reliability"/>
		<description>Null pointer dereference</description>
	</rule>
	<rule>
		<key>exceptThrowInDestructor</key>
		<priority>MAJOR</priority>
		<name>exceptThrowInDestructor</name>
		<configKey>exceptThrowInDestructor</configKey>
		<category name="Reliability"/>
		<description>Throwing exception in destructor</description>
	</rule>
	<rule>
		<key>exceptDeallocThrow</key>
		<priority>MAJOR</priority>
		<name>exceptDeallocThrow</name>
		<configKey>exceptDeallocThrow</configKey>
		<category name="Reliability"/>
		<description>Throwing exception in invalid state, variable points at deallocated memory</description>
	</rule>
	<rule>
		<key>unusedFunction</key>
		<priority>INFO</priority>
		<name>unusedFunction</name>
		<configKey>unusedFunction</configKey>
		<category name="Reliability"/>
		<description>The function is never used</description>
	</rule>
	<rule>
		<key>invalidscanf</key>
		<priority>MINOR</priority>
		<name>invalidscanf</name>
		<configKey>invalidscanf</configKey>
		<category name="Reliability"/>
		<description>scanf without field width limits can crash with huge input data</description>
	</rule>
	<rule>
		<key>unusedVariable</key>
		<priority>INFO</priority>
		<name>unusedVariable</name>
		<configKey>unusedVariable</configKey>
		<category name="Reliability"/>
		<description>Unused variable</description>
	</rule>
	<rule>
		<key>unreadVariable</key>
		<priority>INFO</priority>
		<name>unreadVariable</name>
		<configKey>unreadVariable</configKey>
		<category name="Reliability"/>
		<description>Variable is assigned a value that is never read</description>
	</rule>
	<rule>
		<key>unassignedVariable</key>
		<priority>INFO</priority>
		<name>unassignedVariable</name>
		<configKey>unassignedVariable</configKey>
		<category name="Reliability"/>
		<description>Variable is not assigned a value</description>
	</rule>
	<rule>
		<key>cstyleCast</key>
		<priority>INFO</priority>
		<name>cstyleCast</name>
		<configKey>cstyleCast</configKey>
		<category name="Reliability"/>
		<description>C-style pointer casting</description>
	</rule>
	<rule>
		<key>dangerousUsageStrtol</key>
		<priority>MAJOR</priority>
		<name>dangerousUsageStrtol</name>
		<configKey>dangerousUsageStrtol</configKey>
		<category name="Reliability"/>
		<description>Invalid radix in call to strtol or strtoul. Must be 0 or 2-36</description>
	</rule>
	<rule>
		<key>sprintfOverlappingData</key>
		<priority>MAJOR</priority>
		<name>sprintfOverlappingData</name>
		<configKey>sprintfOverlappingData</configKey>
		<category name="Reliability"/>
		<description>Undefined behaviour: Variable is used wrong in call to sprintf or snprintf. Quote: If copying takes place between objects that overlap as a result of a call to sprintf() or snprintf(), the results are undefined.</description>
	</rule>
	<rule>
		<key>udivError</key>
		<priority>MAJOR</priority>
		<name>udivError</name>
		<configKey>udivError</configKey>
		<category name="Reliability"/>
		<description>Unsigned division. The result will be wrong.</description>
	</rule>
	<rule>
		<key>unusedStructMember</key>
		<priority>INFO</priority>
		<name>unusedStructMember</name>
		<configKey>unusedStructMember</configKey>
		<category name="Reliability"/>
		<description>struct or union member is never used</description>
	</rule>
	<rule>
		<key>passedByValue</key>
		<priority>MINOR</priority>
		<name>passedByValue</name>
		<configKey>passedByValue</configKey>
		<category name="Reliability"/>
		<description>Function parameter  should be passed by reference.</description>
	</rule>
	<rule>
		<key>constStatement</key>
		<priority>MINOR</priority>
		<name>constStatement</name>
		<configKey>constStatement</configKey>
		<category name="Reliability"/>
		<description>Redundant code: Found a statement that begins with constant</description>
	</rule>
	<rule>
		<key>charArrayIndex</key>
		<priority>MINOR</priority>
		<name>charArrayIndex</name>
		<configKey>charArrayIndex</configKey>
		<category name="Reliability"/>
		<description>Using char variable as array index</description>
	</rule>
	<rule>
		<key>charBitOp</key>
		<priority>MINOR</priority>
		<name>charBitOp</name>
		<configKey>charBitOp</configKey>
		<category name="Reliability"/>
		<description>Using char variable in bit operation</description>
	</rule>
	<rule>
		<key>variableScope</key>
		<priority>INFO</priority>
		<name>variableScope</name>
		<configKey>variableScope</configKey>
		<category name="Reliability"/>
		<description>The scope of the variable can be reduced</description>
	</rule>
	<rule>
		<key>conditionAlwaysTrueFalse</key>
		<priority>INFO</priority>
		<name>conditionAlwaysTrueFalse</name>
		<configKey>conditionAlwaysTrueFalse</configKey>
		<category name="Reliability"/>
		<description>Condition is always true or false</description>
	</rule>
	<rule>
		<key>strPlusChar</key>
		<priority>MAJOR</priority>
		<name>strPlusChar</name>
		<configKey>strPlusChar</configKey>
		<category name="Reliability"/>
		<description>Unusual pointer arithmetic</description>
	</rule>
	<rule>
		<key>zerodiv</key>
		<priority>MAJOR</priority>
		<name>zerodiv</name>
		<configKey>zerodiv</configKey>
		<category name="Reliability"/>
		<description>Division by zero</description>
	</rule>
	<rule>
		<key>wrongmathcall</key>
		<priority>MAJOR</priority>
		<name>wrongmathcall</name>
		<configKey>wrongmathcall</configKey>
		<category name="Reliability"/>
		<description>Passed value leads to undefined result</description>
	</rule>
	<rule>
		<key>fflushOnInputStream</key>
		<priority>MAJOR</priority>
		<name>fflushOnInputStream</name>
		<configKey>fflushOnInputStream</configKey>
		<category name="Reliability"/>
		<description>fflush() called on input stream variable may result in undefined behaviour</description>
	</rule>
	<rule>
		<key>sizeofsizeof</key>
		<priority>MINOR</priority>
		<name>sizeofsizeof</name>
		<configKey>sizeofsizeof</configKey>
		<category name="Reliability"/>
		<description>Calling sizeof for 'sizeof'.</description>
	</rule>
	<rule>
		<key>sizeofCalculation</key>
		<priority>MINOR</priority>
		<name>sizeofCalculation</name>
		<configKey>sizeofCalculation</configKey>
		<category name="Reliability"/>
		<description>Found calculation inside sizeof()</description>
	</rule>
	<rule>
		<key>redundantAssignInSwitch</key>
		<priority>MINOR</priority>
		<name>redundantAssignInSwitch</name>
		<configKey>redundantAssignInSwitch</configKey>
		<category name="Reliability"/>
		<description>Redundant assignment of variable in switch</description>
	</rule>
	<rule>
		<key>selfAssignment</key>
		<priority>MINOR</priority>
		<name>selfAssignment</name>
		<configKey>selfAssignment</configKey>
		<category name="Reliability"/>
		<description>Redundant assignment of variable to itself</description>
	</rule>
	<rule>
		<key>assignmentInAssert</key>
		<priority>MINOR</priority>
		<name>assignmentInAssert</name>
		<configKey>assignmentInAssert</configKey>
		<category name="Reliability"/>
		<description>Assert statement modifies variable.</description>
	</rule>
	<rule>
		<key>incorrectLogicOperator</key>
		<priority>MINOR</priority>
		<name>incorrectLogicOperator</name>
		<configKey>incorrectLogicOperator</configKey>
		<category name="Reliability"/>
		<description>Mutual exclusion over || always evaluates to true. Did you intend to use &amp;&amp; instead?</description>
	</rule>
	<rule>
		<key>unusedScopedObject</key>
		<priority>MAJOR</priority>
		<name>unusedScopedObject</name>
		<configKey>unusedScopedObject</configKey>
		<category name="Reliability"/>
		<description>instance of variable object destroyed immediately</description>
	</rule>
	<rule>
		<key>noConstructor</key>
		<priority>INFO</priority>
		<name>noConstructor</name>
		<configKey>noConstructor</configKey>
		<category name="Reliability"/>
		<description>The class does not have a constructor.</description>
	</rule>
	<rule>
		<key>operatorEqVarError</key>
		<priority>MINOR</priority>
		<name>operatorEqVarError</name>
		<configKey>operatorEqVarError</configKey>
		<category name="Reliability"/>
		<description>Member variable is not assigned a value</description>
	</rule>
	<rule>
		<key>unusedPrivateFunction</key>
		<priority>INFO</priority>
		<name>unusedPrivateFunction</name>
		<configKey>unusedPrivateFunction</configKey>
		<category name="Reliability"/>
		<description>Unused private function</description>
	</rule>
	<rule>
		<key>memsetClass</key>
		<priority>MAJOR</priority>
		<name>memsetClass</name>
		<configKey>memsetClass</configKey>
		<category name="Reliability"/>
		<description>Using memfunc on class</description>
	</rule>
	<rule>
		<key>memsetStruct</key>
		<priority>MAJOR</priority>
		<name>memsetStruct</name>
		<configKey>memsetStruct</configKey>
		<category name="Reliability"/>
		<description>Using memfunc on struct that contains a 'std::'</description>
	</rule>
	<rule>
		<key>operatorEq</key>
		<priority>INFO</priority>
		<name>operatorEq</name>
		<configKey>operatorEq</configKey>
		<category name="Reliability"/>
		<description>'operator=' should return something</description>
	</rule>
	<rule>
		<key>operatorEqRetRefThis</key>
		<priority>INFO</priority>
		<name>operatorEqRetRefThis</name>
		<configKey>operatorEqRetRefThis</configKey>
		<category name="Reliability"/>
		<description>'operator=' should return reference to self</description>
	</rule>
	<rule>
		<key>operatorEqToSelf</key>
		<priority>MINOR</priority>
		<name>operatorEqToSelf</name>
		<configKey>operatorEqToSelf</configKey>
		<category name="Reliability"/>
		<description>'operator=' should check for assignment to self</description>
	</rule>
	<rule>
		<key>virtualDestructor</key>
		<priority>MAJOR</priority>
		<name>virtualDestructor</name>
		<configKey>virtualDestructor</configKey>
		<category name="Reliability"/>
		<description>Class which is inherited does not have a virtual destructor</description>
	</rule>
	<rule>
		<key>thisSubtraction</key>
		<priority>MINOR</priority>
		<name>thisSubtraction</name>
		<configKey>thisSubtraction</configKey>
		<category name="Reliability"/>
		<description>Suspicious pointer subtraction</description>
	</rule>
	<rule>
		<key>functionConst</key>
		<priority>INFO</priority>
		<name>functionConst</name>
		<configKey>functionConst</configKey>
		<category name="Reliability"/>
		<description>The function  can be const</description>
	</rule>
	<rule>
		<key>arrayIndexOutOfBounds</key>
		<priority>MAJOR</priority>
		<name>arrayIndexOutOfBounds</name>
		<configKey>arrayIndexOutOfBounds</configKey>
		<category name="Reliability"/>
		<description>[index] out of bounds</description>
	</rule>
	<rule>
		<key>bufferAccessOutOfBounds</key>
		<priority>MAJOR</priority>
		<name>bufferAccessOutOfBounds</name>
		<configKey>bufferAccessOutOfBounds</configKey>
		<category name="Reliability"/>
		<description>Buffer access out-of-bounds</description>
	</rule>
	<rule>
		<key>strncatUsage</key>
		<priority>MINOR</priority>
		<name>strncatUsage</name>
		<configKey>strncatUsage</configKey>
		<category name="Reliability"/>
		<description>Dangerous usage of strncat. Tip: the 3rd parameter means maximum number of characters to append</description>
	</rule>
	<rule>
		<key>outOfBounds</key>
		<priority>MAJOR</priority>
		<name>outOfBounds</name>
		<configKey>outOfBounds</configKey>
		<category name="Reliability"/>
		<description>This is out of bounds</description>
	</rule>
	<rule>
		<key>sizeArgumentAsChar</key>
		<priority>MINOR</priority>
		<name>sizeArgumentAsChar</name>
		<configKey>sizeArgumentAsChar</configKey>
		<category name="Reliability"/>
		<description>The size argument is given as a char constant</description>
	</rule>
	<rule>
		<key>terminateStrncpy</key>
		<priority>MINOR</priority>
		<name>terminateStrncpy</name>
		<configKey>terminateStrncpy</configKey>
		<category name="Reliability"/>
		<description>After a strncpy() the buffer should be zero-terminated</description>
	</rule>
	<rule>
		<key>insecureCmdLineArgs</key>
		<priority>MAJOR</priority>
		<name>insecureCmdLineArgs</name>
		<configKey>insecureCmdLineArgs</configKey>
		<category name="Reliability"/>
		<description>Buffer overrun possible for long cmd-line args</description>
	</rule>
	<rule>
		<key>negativeIndex</key>
		<priority>MAJOR</priority>
		<name>negativeIndex</name>
		<configKey>negativeIndex</configKey>
		<category name="Reliability"/>
		<description>[index] negative or out of bounds</description>
	</rule>
	<rule>
		<key>invalidIterator1</key>
		<priority>MAJOR</priority>
		<name>invalidIterator1</name>
		<configKey>invalidIterator1</configKey>
		<category name="Reliability"/>
		<description>Invalid iterator</description>
	</rule>
	<rule>
		<key>iterators</key>
		<priority>MAJOR</priority>
		<name>iterators</name>
		<configKey>iterators</configKey>
		<category name="Reliability"/>
		<description>Same iterator is used with both containers</description>
	</rule>
	<rule>
		<key>eraseDereference</key>
		<priority>MAJOR</priority>
		<name>eraseDereference</name>
		<configKey>eraseDereference</configKey>
		<category name="Reliability"/>
		<description>Dereferenced iterator has been erased</description>
	</rule>
	<rule>
		<key>eraseByValue</key>
		<priority>MAJOR</priority>
		<name>eraseByValue</name>
		<configKey>eraseByValue</configKey>
		<category name="Reliability"/>
		<description>Iterator becomes invalid when deleted by value</description>
	</rule>
	<rule>
		<key>mismatchingContainers</key>
		<priority>MAJOR</priority>
		<name>mismatchingContainers</name>
		<configKey>mismatchingContainers</configKey>
		<category name="Reliability"/>
		<description>mismatching containers</description>
	</rule>
	<rule>
		<key>stlOutOfBounds</key>
		<priority>MAJOR</priority>
		<name>stlOutOfBounds</name>
		<configKey>stlOutOfBounds</configKey>
		<category name="Reliability"/>
		<description>Container[Container.size] is out of bounds</description>
	</rule>
	<rule>
		<key>erase</key>
		<priority>MAJOR</priority>
		<name>erase</name>
		<configKey>erase</configKey>
		<category name="Reliability"/>
		<description>Dangerous iterator usage. After erase the iterator is invalid so dereferencing it or comparing it with another iterator is invalid.</description>
	</rule>
	<rule>
		<key>invalidIterator2</key>
		<priority>MAJOR</priority>
		<name>invalidIterator2</name>
		<configKey>invalidIterator2</configKey>
		<category name="Reliability"/>
		<description>After function call iterator may be invalid</description>
	</rule>
	<rule>
		<key>invalidPointer</key>
		<priority>MAJOR</priority>
		<name>invalidPointer</name>
		<configKey>invalidPointer</configKey>
		<category name="Reliability"/>
		<description>Invalid pointerafter push_back / push_front</description>
	</rule>
	<rule>
		<key>stlBoundries</key>
		<priority>MAJOR</priority>
		<name>stlBoundries</name>
		<configKey>stlBoundries</configKey>
		<category name="Reliability"/>
		<description>Container range check should use != and not &gt; since the order of the pointers isn't guaranteed</description>
	</rule>
	<rule>
		<key>stlIfStrFind</key>
		<priority>MINOR</priority>
		<name>stlIfStrFind</name>
		<configKey>stlIfStrFind</configKey>
		<category name="Reliability"/>
		<description>Suspicious condition. string::find will return 0 if the string is found at position 0. If this is what you want to check then string::compare is a faster alternative because it doesn't scan through the string.</description>
	</rule>
	<rule>
		<key>stlIfFind</key>
		<priority>MINOR</priority>
		<name>stlIfFind</name>
		<configKey>stlIfFind</configKey>
		<category name="Reliability"/>
		<description>Suspicious condition. The result of find is an iterator, but it is not properly checked.</description>
	</rule>
	<rule>
		<key>stlSize</key>
		<priority>MINOR</priority>
		<name>stlSize</name>
		<configKey>stlSize</configKey>
		<category name="Reliability"/>
		<description>Possible inefficient checking for Variable emptiness. Using .empty() instead of .size() can be faster.</description>
	</rule>
	<rule>
		<key>redundantIfRemove</key>
		<priority>INFO</priority>
		<name>redundantIfRemove</name>
		<configKey>redundantIfRemove</configKey>
		<category name="Reliability"/>
		<description>Redundant checking of STL container element.</description>
	</rule>
	<rule>
		<key>StlMissingComparison</key>
		<priority>MINOR</priority>
		<name>StlMissingComparison</name>
		<configKey>StlMissingComparison</configKey>
		<category name="Reliability"/>
		<description>Missing bounds check for extra iterator increment in loop.</description>
	</rule>
	<rule>
		<key>stlcstr</key>
		<priority>MAJOR</priority>
		<name>stlcstr</name>
		<configKey>stlcstr</configKey>
		<category name="Reliability"/>
		<description>Dangerous usage of c_str()</description>
	</rule>
	<rule>
		<key>postfixOperator</key>
		<priority>MINOR</priority>
		<name>postfixOperator</name>
		<configKey>postfixOperator</configKey>
		<category name="Reliability"/>
		<description>Prefer prefix ++/-- operators for non-primitive types. Pre-increment/decrement can be more efficient than post-increment/decrement. Post-increment/decrement usually involves keeping a copy of the previous value around and adds a little extra code.</description>
	</rule>
</rules>
